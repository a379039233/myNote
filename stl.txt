bool sort_by_id(const User& obj1,const User& obj2)
 59 {
 60     return obj1.id < obj2.id;
 61 }
Vectors：将元素置于一个动态数组中加以管理，可以随机存取元素（用索引直接存取），数组尾部添加或移除元素非常快速。但是在中部或头部安插元素比较费时；

   Deques：是“double-ended queue”的缩写，可以随机存取元素（用索引直接存取），数组头部和尾部添加或移除元素都非常快速。但是在中部或头部安插元素比较费时；

   Lists：双向链表，不提供随机存取（按顺序走到需存取的元素，O(n)），在任何位置上执行插入或删除动作都非常迅速，内部只需调整一下指针；

1、如果你需要高效的随即存取，而不在乎插入和删除的效率，使用vector 
      2、如果你需要大量的插入和删除，而不关心随即存取，则应使用list 
      3、如果你需要随即存取，而且关心两端数据的插入和删除，则应使用deque。
 不同的是deque的动态数组头尾都开放，因此能在头尾两端进行快速安插和删除。
 c++标准建议：vector是那种应该在默认情况下使用的序列。如果大多数插入和删除操作发生在序列的头部或尾部时，应该选用deque。


这个例子演示了find_if()，它接收一个函数对象的参数作为参数，并使用它来做更复杂的评价对象是否和给出的查找条件相付。
	  
	  
	  xml;
	  tinyxml;
	  
	  sqllite,oracle,
	  
	   从理论上来看，微内核的思想更好些，微内核把系统分为各个小的功能块，降低了设计难度，系统的维护与修改也容易，但通信带来的效率损失是个问题。宏内核的功能块之间的耦合度太高造成修改与维护的代价太高，不过在目前的Linux里面还不算大问题，因为Linux目前还不算太复杂，宏内核因为是直接调用，所以效率是比较高的。
	   
	   
	   非常不幸，你在代码中遇到这么多的动态内存分配，但这个只能说明有现在有太多不合格的 C++ 程序员。

这么说吧，你的两个问题本质上是同个问题。第一个问题是，应该何时使用动态分配（使用 new 方法）？第二问题是，什么时候该使用指针？

最先要牢记的重点是，你应该根据实际需求选择合适的方法。 一般来说，使用定义对象的方式比起使用手工动态分配（或new指针）的方式会更加合理以及安全。
动态分配

你的提问中，所列出的两种分配对象方式的主要区别在于对象的生存期。通过 Object myObject 方式定义对象，对象的生存期是在其作用域内自维护（automatic storage），这个意味着程序离开对象的作用域之后，对象将被自动销毁。当通过 new Object() 方式分配对象时，对象的生存期是动态的，这个意味着若不显式地 detete 对象，对象将一直存在。你应该只在必要的时候使用动态分配对象。换句话说，只要有可能，你应该首选定义可自维护的对象。


他也提到长期保持较高的工作效率的技巧是每天只工作一段的时间。3hour.但是当你每天只有几个小时工作的时候，你会更加严肃对待。
